var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"test","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * ert_main.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"test.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n  __enable_irq();\r\n  test_step();\r\n\r\n  /* Get model outputs here */\r\n  __disable_irq();\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(int argc, char **argv)\r\n{\r\n  float modelBaseRate = 0.1;\r\n  float systemClock = 168;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n\r\n#ifndef USE_RTX\r\n#if defined(MW_MULTI_TASKING_MODE) && (MW_MULTI_TASKING_MODE == 1)\r\n\r\n  MW_ASM (\" SVC #1\");\r\n\r\n#endif\r\n\r\n  __disable_irq();\r\n\r\n#endif\r\n\r\n  ;\r\n  stm32f4xx_init_board();\r\n  SystemCoreClockUpdate();\r\n  bootloaderInit();\r\n  rtmSetErrorStatus(test_M, 0);\r\n  test_initialize();\r\n  __disable_irq();\r\n  ARMCM_SysTick_Config(modelBaseRate);\r\n  runModel =\r\n    rtmGetErrorStatus(test_M) == (NULL);\r\n  __enable_irq();\r\n  __enable_irq();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(test_M) == (NULL));\r\n    runModel = !(stopRequested);\r\n  }\r\n\r\n  /* Terminate model */\r\n  test_terminate();\r\n\r\n#ifndef USE_RTX\r\n\r\n  (void)systemClock;\r\n\r\n#endif\r\n\r\n  ;\r\n  __disable_irq();\r\n  return 0;\r\n}\r\n"},{"name":"test.c","type":"source","group":"model","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * test.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"test.h\"\r\n#include \"test_private.h\"\r\n\r\n/* Block states (default storage) */\r\nDW_test_T test_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_test_T test_M_;\r\nRT_MODEL_test_T *const test_M = &test_M_;\r\n\r\n/* Model step function */\r\nvoid test_step(void)\r\n{\r\n  GPIO_TypeDef * portNameLoc;\r\n  real_T tmp;\r\n  int32_T pinWriteLoc;\r\n\r\n  /* MATLABSystem: '<S4>/Digital Port Write' */\r\n  portNameLoc = GPIOB;\r\n\r\n  /* Switch: '<Root>/Switch' incorporates:\r\n   *  Constant: '<Root>/OFF'\r\n   *  Constant: '<Root>/ON'\r\n   *  Constant: '<S1>/Constant'\r\n   *  RelationalOperator: '<S1>/Compare'\r\n   *  Sin: '<Root>/Sine Wave'\r\n   */\r\n  if (sin(((real_T)test_DW.counter + test_P.SineWave_Offset) * 2.0 *\r\n          3.1415926535897931 / test_P.SineWave_NumSamp) * test_P.SineWave_Amp +\r\n      test_P.SineWave_Bias >= test_P.CompareToConstant_const) {\r\n    tmp = test_P.ON_Value;\r\n  } else {\r\n    tmp = test_P.OFF_Value;\r\n  }\r\n\r\n  /* End of Switch: '<Root>/Switch' */\r\n\r\n  /* MATLABSystem: '<S4>/Digital Port Write' */\r\n  if (tmp != 0.0) {\r\n    pinWriteLoc = 2;\r\n  } else {\r\n    pinWriteLoc = 0;\r\n  }\r\n\r\n  LL_GPIO_SetOutputPin(portNameLoc, (uint32_T)pinWriteLoc);\r\n  LL_GPIO_ResetOutputPin(portNameLoc, ~(uint32_T)pinWriteLoc & 2U);\r\n\r\n  /* Update for Sin: '<Root>/Sine Wave' */\r\n  test_DW.counter++;\r\n  if (test_DW.counter == test_P.SineWave_NumSamp) {\r\n    test_DW.counter = 0;\r\n  }\r\n\r\n  /* End of Update for Sin: '<Root>/Sine Wave' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid test_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(test_M, (NULL));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&test_DW, 0,\r\n                sizeof(DW_test_T));\r\n\r\n  /* InitializeConditions for Sin: '<Root>/Sine Wave' */\r\n  test_DW.counter = 0;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid test_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"test.h","type":"header","group":"model","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * test.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_test_h_\r\n#define RTW_HEADER_test_h_\r\n#include <math.h>\r\n#include <stddef.h>\r\n#include <string.h>\r\n#ifndef test_COMMON_INCLUDES_\r\n#define test_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"main.h\"\r\n#endif                                 /* test_COMMON_INCLUDES_ */\r\n\r\n#include \"test_types.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  int32_T counter;                     /* '<Root>/Sine Wave' */\r\n} DW_test_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_test_T_ {\r\n  real_T CompareToConstant_const;     /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S1>/Constant'\r\n                                       */\r\n  real_T ON_Value;                     /* Expression: 1\r\n                                        * Referenced by: '<Root>/ON'\r\n                                        */\r\n  real_T OFF_Value;                    /* Expression: 0\r\n                                        * Referenced by: '<Root>/OFF'\r\n                                        */\r\n  real_T SineWave_Amp;                 /* Expression: 5\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n  real_T SineWave_Bias;                /* Expression: 0\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n  real_T SineWave_NumSamp;             /* Expression: 10\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n  real_T SineWave_Offset;              /* Expression: 0\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_test_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_test_T test_P;\r\n\r\n/* Block states (default storage) */\r\nextern DW_test_T test_DW;\r\n\r\n/* Model entry point functions */\r\nextern void test_initialize(void);\r\nextern void test_step(void);\r\nextern void test_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_test_T *const test_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Scope' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'test'\r\n * '<S1>'   : 'test/Compare To Constant'\r\n * '<S2>'   : 'test/Digital Port Write'\r\n * '<S3>'   : 'test/Digital Port Write/ECSoC'\r\n * '<S4>'   : 'test/Digital Port Write/ECSoC/ECSimCodegen'\r\n */\r\n#endif                                 /* RTW_HEADER_test_h_ */\r\n"},{"name":"test_private.h","type":"header","group":"model","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * test_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_test_private_h_\r\n#define RTW_HEADER_test_private_h_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* RTW_HEADER_test_private_h_ */\r\n"},{"name":"test_types.h","type":"header","group":"model","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * test_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_test_types_h_\r\n#define RTW_HEADER_test_types_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Model Code Variants */\r\n#ifndef struct_tag_BlgwLpgj2bjudmbmVKWwDE\r\n#define struct_tag_BlgwLpgj2bjudmbmVKWwDE\r\n\r\nstruct tag_BlgwLpgj2bjudmbmVKWwDE\r\n{\r\n  uint32_T f1[8];\r\n};\r\n\r\n#endif                                 /* struct_tag_BlgwLpgj2bjudmbmVKWwDE */\r\n\r\n#ifndef typedef_cell_wrap_test_T\r\n#define typedef_cell_wrap_test_T\r\n\r\ntypedef struct tag_BlgwLpgj2bjudmbmVKWwDE cell_wrap_test_T;\r\n\r\n#endif                                 /* typedef_cell_wrap_test_T */\r\n\r\n#ifndef struct_tag_pXqB0JYFCgtuRHpfOp5C9\r\n#define struct_tag_pXqB0JYFCgtuRHpfOp5C9\r\n\r\nstruct tag_pXqB0JYFCgtuRHpfOp5C9\r\n{\r\n  int32_T isInitialized;\r\n  cell_wrap_test_T inputVarSize;\r\n};\r\n\r\n#endif                                 /* struct_tag_pXqB0JYFCgtuRHpfOp5C9 */\r\n\r\n#ifndef typedef_stm32cube_blocks_DigitalPortW_T\r\n#define typedef_stm32cube_blocks_DigitalPortW_T\r\n\r\ntypedef struct tag_pXqB0JYFCgtuRHpfOp5C9 stm32cube_blocks_DigitalPortW_T;\r\n\r\n#endif                             /* typedef_stm32cube_blocks_DigitalPortW_T */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_test_T_ P_test_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_test_T RT_MODEL_test_T;\r\n\r\n#endif                                 /* RTW_HEADER_test_types_h_ */\r\n"},{"name":"test_data.c","type":"source","group":"data","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * test_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"test.h\"\r\n#include \"test_private.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_test_T test_P = {\r\n  /* Mask Parameter: CompareToConstant_const\r\n   * Referenced by: '<S1>/Constant'\r\n   */\r\n  3.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/ON'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/OFF'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 5\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  5.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 10\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  10.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  0.0\r\n};\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * rtmodel.h\r\n *\r\n * Code generation for Simulink model \"test\".\r\n *\r\n * Simulink Coder version                : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Feb  7 12:17:20 2023\r\n *\r\n * Note that the generated code is not dependent on this header file.\r\n * The file is used in cojuction with the automatic build procedure.\r\n * It is included by the sample main executable harness\r\n * MATLAB/rtw/c/src/common/rt_main.c.\r\n *\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"test.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"system_stm32f4xx.h\"\n#include \"blapp_support.h\"\n#include \"stm32f4discovery_wrapper.h\"\n#include \"SysTickScheduler.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE STM32F4-Discovery\n#define MW_CONNECTIONINFO_SERIAL_BAUDRATE 460800\n#define MW_CONNECTIONINFO_SERIAL_COMPORT COM20\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION Serial\n#define MW_RTOS Baremetal\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT 0\n#define MW_RUNTIME_BOOTLOADERCHOICE 0\n#define MW_RUNTIME_BOOTLOADERCOMPORT COM1\n#define MW_RUNTIME_BOOTLOADERAPPLICATIONHASCOM 0\n#define MW_RUNTIME_BOOTLOADERPROTECTEDTARGET 0\n#define MW_RUNTIME_LOADNEWBOOTLOADER 1\n#define MW_RUNTIME_BOOTLOADERCOMPATIBLEOS 1\n#define MW_RUNTIME_SHOWPROTECTEDOPTIONS 0\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 168\n#define MW_PIL_INTERFACE 0\n#define MW_PIL_COMPORT COM1\n#define MW_ADC_PRESCALER 0.000000\n#define MW_ADC_DELAYSAMPLEPHASES 0.000000\n#define MW_ADC_ENTEMPSENSVREFINT 0\n#define MW_ADC_ENVBAT 0\n#define MW_ADC_MULTIADC 0.000000\n#define MW_ADC_MULTIADCMODE 0.000000\n#define MW_ADC_DMAMODE 0.000000\n#define MW_ADC_DMAENABLE 0\n#define MW_ADC1_CONVRESOLUTION 0.000000\n#define MW_ADC1_ENDISCONT 0\n#define MW_ADC1_NBOFDISCONTCHL 0.000000\n#define MW_ADC1_ENDISCONTINJ 0\n#define MW_ADC1_DATAALIGN 0.000000\n#define MW_ADC1_ENABLEWATCHDOG 0\n#define MW_ADC1_ENABLEWATCHDOGINJ 0\n#define MW_ADC1_WATCHDOGONCHANNEL 0.000000\n#define MW_ADC1_WATCHDOGLOWTHR 0.000000\n#define MW_ADC1_WATCHDOGHIGHTHR 4095.000000\n#define MW_ADC1_SAMPLETIMECHL0 0.000000\n#define MW_ADC1_SAMPLETIMECHL1 0.000000\n#define MW_ADC1_SAMPLETIMECHL2 0.000000\n#define MW_ADC1_SAMPLETIMECHL3 0.000000\n#define MW_ADC1_SAMPLETIMECHL4 0.000000\n#define MW_ADC1_SAMPLETIMECHL5 0.000000\n#define MW_ADC1_SAMPLETIMECHL6 0.000000\n#define MW_ADC1_SAMPLETIMECHL7 0.000000\n#define MW_ADC1_SAMPLETIMECHL8 0.000000\n#define MW_ADC1_SAMPLETIMECHL9 0.000000\n#define MW_ADC1_SAMPLETIMECHL10 0.000000\n#define MW_ADC1_SAMPLETIMECHL11 0.000000\n#define MW_ADC1_SAMPLETIMECHL12 0.000000\n#define MW_ADC1_SAMPLETIMECHL13 0.000000\n#define MW_ADC1_SAMPLETIMECHL14 0.000000\n#define MW_ADC1_SAMPLETIMECHL15 0.000000\n#define MW_ADC1_SAMPLETIMECHL16 0.000000\n#define MW_ADC1_SAMPLETIMECHL17 0.000000\n#define MW_ADC1_SAMPLETIMECHL18 0.000000\n#define MW_ADC2_CONVRESOLUTION 0.000000\n#define MW_ADC2_ENDISCONT 0\n#define MW_ADC2_NBOFDISCONTCHL 0.000000\n#define MW_ADC2_ENDISCONTINJ 0\n#define MW_ADC2_DATAALIGN 0.000000\n#define MW_ADC2_ENABLEWATCHDOG 0\n#define MW_ADC2_ENABLEWATCHDOGINJ 0\n#define MW_ADC2_WATCHDOGONCHANNEL 0.000000\n#define MW_ADC2_WATCHDOGLOWTHR 0.000000\n#define MW_ADC2_WATCHDOGHIGHTHR 4095.000000\n#define MW_ADC2_SAMPLETIMECHL0 0.000000\n#define MW_ADC2_SAMPLETIMECHL1 0.000000\n#define MW_ADC2_SAMPLETIMECHL2 0.000000\n#define MW_ADC2_SAMPLETIMECHL3 0.000000\n#define MW_ADC2_SAMPLETIMECHL4 0.000000\n#define MW_ADC2_SAMPLETIMECHL5 0.000000\n#define MW_ADC2_SAMPLETIMECHL6 0.000000\n#define MW_ADC2_SAMPLETIMECHL7 0.000000\n#define MW_ADC2_SAMPLETIMECHL8 0.000000\n#define MW_ADC2_SAMPLETIMECHL9 0.000000\n#define MW_ADC2_SAMPLETIMECHL10 0.000000\n#define MW_ADC2_SAMPLETIMECHL11 0.000000\n#define MW_ADC2_SAMPLETIMECHL12 0.000000\n#define MW_ADC2_SAMPLETIMECHL13 0.000000\n#define MW_ADC2_SAMPLETIMECHL14 0.000000\n#define MW_ADC2_SAMPLETIMECHL15 0.000000\n#define MW_ADC2_SAMPLETIMECHL16 0.000000\n#define MW_ADC2_SAMPLETIMECHL17 0.000000\n#define MW_ADC2_SAMPLETIMECHL18 0.000000\n#define MW_ADC3_CONVRESOLUTION 0.000000\n#define MW_ADC3_ENDISCONT 0\n#define MW_ADC3_NBOFDISCONTCHL 0.000000\n#define MW_ADC3_ENDISCONTINJ 0\n#define MW_ADC3_DATAALIGN 0.000000\n#define MW_ADC3_ENABLEWATCHDOG 0\n#define MW_ADC3_ENABLEWATCHDOGINJ 0\n#define MW_ADC3_WATCHDOGONCHANNEL 0.000000\n#define MW_ADC3_WATCHDOGLOWTHR 0.000000\n#define MW_ADC3_WATCHDOGHIGHTHR 4095.000000\n#define MW_ADC3_SAMPLETIMECHL0 0.000000\n#define MW_ADC3_SAMPLETIMECHL1 0.000000\n#define MW_ADC3_SAMPLETIMECHL2 0.000000\n#define MW_ADC3_SAMPLETIMECHL3 0.000000\n#define MW_ADC3_SAMPLETIMECHL4 0.000000\n#define MW_ADC3_SAMPLETIMECHL5 0.000000\n#define MW_ADC3_SAMPLETIMECHL6 0.000000\n#define MW_ADC3_SAMPLETIMECHL7 0.000000\n#define MW_ADC3_SAMPLETIMECHL8 0.000000\n#define MW_ADC3_SAMPLETIMECHL9 0.000000\n#define MW_ADC3_SAMPLETIMECHL10 0.000000\n#define MW_ADC3_SAMPLETIMECHL11 0.000000\n#define MW_ADC3_SAMPLETIMECHL12 0.000000\n#define MW_ADC3_SAMPLETIMECHL13 0.000000\n#define MW_ADC3_SAMPLETIMECHL14 0.000000\n#define MW_ADC3_SAMPLETIMECHL15 0.000000\n#define MW_ADC3_SAMPLETIMECHL16 0.000000\n#define MW_ADC3_SAMPLETIMECHL17 0.000000\n#define MW_ADC3_SAMPLETIMECHL18 0.000000\n#define MW_GPIOA_SHOWPINSETTING 0\n#define MW_GPIOA_OUTTYPEREGPIN0 0\n#define MW_GPIOA_OUTSPEEDREGPIN0 0\n#define MW_GPIOA_PUPDREGPIN0 0\n#define MW_GPIOA_OUTTYPEREGPIN1 0\n#define MW_GPIOA_OUTSPEEDREGPIN1 0\n#define MW_GPIOA_PUPDREGPIN1 0\n#define MW_GPIOA_OUTTYPEREGPIN2 0\n#define MW_GPIOA_OUTSPEEDREGPIN2 0\n#define MW_GPIOA_PUPDREGPIN2 0\n#define MW_GPIOA_OUTTYPEREGPIN3 0\n#define MW_GPIOA_OUTSPEEDREGPIN3 0\n#define MW_GPIOA_PUPDREGPIN3 0\n#define MW_GPIOA_OUTTYPEREGPIN4 0\n#define MW_GPIOA_OUTSPEEDREGPIN4 0\n#define MW_GPIOA_PUPDREGPIN4 0\n#define MW_GPIOA_OUTTYPEREGPIN5 0\n#define MW_GPIOA_OUTSPEEDREGPIN5 0\n#define MW_GPIOA_PUPDREGPIN5 0\n#define MW_GPIOA_OUTTYPEREGPIN6 0\n#define MW_GPIOA_OUTSPEEDREGPIN6 0\n#define MW_GPIOA_PUPDREGPIN6 0\n#define MW_GPIOA_OUTTYPEREGPIN7 0\n#define MW_GPIOA_OUTSPEEDREGPIN7 0\n#define MW_GPIOA_PUPDREGPIN7 0\n#define MW_GPIOA_OUTTYPEREGPIN8 0\n#define MW_GPIOA_OUTSPEEDREGPIN8 0\n#define MW_GPIOA_PUPDREGPIN8 0\n#define MW_GPIOA_OUTTYPEREGPIN9 0\n#define MW_GPIOA_OUTSPEEDREGPIN9 0\n#define MW_GPIOA_PUPDREGPIN9 0\n#define MW_GPIOA_OUTTYPEREGPIN10 0\n#define MW_GPIOA_OUTSPEEDREGPIN10 0\n#define MW_GPIOA_PUPDREGPIN10 0\n#define MW_GPIOA_OUTTYPEREGPIN11 0\n#define MW_GPIOA_OUTSPEEDREGPIN11 0\n#define MW_GPIOA_PUPDREGPIN11 0\n#define MW_GPIOA_OUTTYPEREGPIN12 0\n#define MW_GPIOA_OUTSPEEDREGPIN12 0\n#define MW_GPIOA_PUPDREGPIN12 0\n#define MW_GPIOA_OUTTYPEREGPIN13 0\n#define MW_GPIOA_OUTSPEEDREGPIN13 0\n#define MW_GPIOA_PUPDREGPIN13 0\n#define MW_GPIOA_OUTTYPEREGPIN14 0\n#define MW_GPIOA_OUTSPEEDREGPIN14 0\n#define MW_GPIOA_PUPDREGPIN14 0\n#define MW_GPIOA_OUTTYPEREGPIN15 0\n#define MW_GPIOA_OUTSPEEDREGPIN15 0\n#define MW_GPIOA_PUPDREGPIN15 0\n#define MW_GPIOB_SHOWPINSETTING 0\n#define MW_GPIOB_OUTTYPEREGPIN0 0\n#define MW_GPIOB_OUTSPEEDREGPIN0 0\n#define MW_GPIOB_PUPDREGPIN0 0\n#define MW_GPIOB_OUTTYPEREGPIN1 0\n#define MW_GPIOB_OUTSPEEDREGPIN1 0\n#define MW_GPIOB_PUPDREGPIN1 0\n#define MW_GPIOB_OUTTYPEREGPIN2 0\n#define MW_GPIOB_OUTSPEEDREGPIN2 0\n#define MW_GPIOB_PUPDREGPIN2 0\n#define MW_GPIOB_OUTTYPEREGPIN3 0\n#define MW_GPIOB_OUTSPEEDREGPIN3 0\n#define MW_GPIOB_PUPDREGPIN3 0\n#define MW_GPIOB_OUTTYPEREGPIN4 0\n#define MW_GPIOB_OUTSPEEDREGPIN4 0\n#define MW_GPIOB_PUPDREGPIN4 0\n#define MW_GPIOB_OUTTYPEREGPIN5 0\n#define MW_GPIOB_OUTSPEEDREGPIN5 0\n#define MW_GPIOB_PUPDREGPIN5 0\n#define MW_GPIOB_OUTTYPEREGPIN6 0\n#define MW_GPIOB_OUTSPEEDREGPIN6 0\n#define MW_GPIOB_PUPDREGPIN6 0\n#define MW_GPIOB_OUTTYPEREGPIN7 0\n#define MW_GPIOB_OUTSPEEDREGPIN7 0\n#define MW_GPIOB_PUPDREGPIN7 0\n#define MW_GPIOB_OUTTYPEREGPIN8 0\n#define MW_GPIOB_OUTSPEEDREGPIN8 0\n#define MW_GPIOB_PUPDREGPIN8 0\n#define MW_GPIOB_OUTTYPEREGPIN9 0\n#define MW_GPIOB_OUTSPEEDREGPIN9 0\n#define MW_GPIOB_PUPDREGPIN9 0\n#define MW_GPIOB_OUTTYPEREGPIN10 0\n#define MW_GPIOB_OUTSPEEDREGPIN10 0\n#define MW_GPIOB_PUPDREGPIN10 0\n#define MW_GPIOB_OUTTYPEREGPIN11 0\n#define MW_GPIOB_OUTSPEEDREGPIN11 0\n#define MW_GPIOB_PUPDREGPIN11 0\n#define MW_GPIOB_OUTTYPEREGPIN12 0\n#define MW_GPIOB_OUTSPEEDREGPIN12 0\n#define MW_GPIOB_PUPDREGPIN12 0\n#define MW_GPIOB_OUTTYPEREGPIN13 0\n#define MW_GPIOB_OUTSPEEDREGPIN13 0\n#define MW_GPIOB_PUPDREGPIN13 0\n#define MW_GPIOB_OUTTYPEREGPIN14 0\n#define MW_GPIOB_OUTSPEEDREGPIN14 0\n#define MW_GPIOB_PUPDREGPIN14 0\n#define MW_GPIOB_OUTTYPEREGPIN15 0\n#define MW_GPIOB_OUTSPEEDREGPIN15 0\n#define MW_GPIOB_PUPDREGPIN15 0\n#define MW_GPIOC_SHOWPINSETTING 0\n#define MW_GPIOC_OUTTYPEREGPIN0 0\n#define MW_GPIOC_OUTSPEEDREGPIN0 0\n#define MW_GPIOC_PUPDREGPIN0 0\n#define MW_GPIOC_OUTTYPEREGPIN1 0\n#define MW_GPIOC_OUTSPEEDREGPIN1 0\n#define MW_GPIOC_PUPDREGPIN1 0\n#define MW_GPIOC_OUTTYPEREGPIN2 0\n#define MW_GPIOC_OUTSPEEDREGPIN2 0\n#define MW_GPIOC_PUPDREGPIN2 0\n#define MW_GPIOC_OUTTYPEREGPIN3 0\n#define MW_GPIOC_OUTSPEEDREGPIN3 0\n#define MW_GPIOC_PUPDREGPIN3 0\n#define MW_GPIOC_OUTTYPEREGPIN4 0\n#define MW_GPIOC_OUTSPEEDREGPIN4 0\n#define MW_GPIOC_PUPDREGPIN4 0\n#define MW_GPIOC_OUTTYPEREGPIN5 0\n#define MW_GPIOC_OUTSPEEDREGPIN5 0\n#define MW_GPIOC_PUPDREGPIN5 0\n#define MW_GPIOC_OUTTYPEREGPIN6 0\n#define MW_GPIOC_OUTSPEEDREGPIN6 0\n#define MW_GPIOC_PUPDREGPIN6 0\n#define MW_GPIOC_OUTTYPEREGPIN7 0\n#define MW_GPIOC_OUTSPEEDREGPIN7 0\n#define MW_GPIOC_PUPDREGPIN7 0\n#define MW_GPIOC_OUTTYPEREGPIN8 0\n#define MW_GPIOC_OUTSPEEDREGPIN8 0\n#define MW_GPIOC_PUPDREGPIN8 0\n#define MW_GPIOC_OUTTYPEREGPIN9 0\n#define MW_GPIOC_OUTSPEEDREGPIN9 0\n#define MW_GPIOC_PUPDREGPIN9 0\n#define MW_GPIOC_OUTTYPEREGPIN10 0\n#define MW_GPIOC_OUTSPEEDREGPIN10 0\n#define MW_GPIOC_PUPDREGPIN10 0\n#define MW_GPIOC_OUTTYPEREGPIN11 0\n#define MW_GPIOC_OUTSPEEDREGPIN11 0\n#define MW_GPIOC_PUPDREGPIN11 0\n#define MW_GPIOC_OUTTYPEREGPIN12 0\n#define MW_GPIOC_OUTSPEEDREGPIN12 0\n#define MW_GPIOC_PUPDREGPIN12 0\n#define MW_GPIOC_OUTTYPEREGPIN13 0\n#define MW_GPIOC_OUTSPEEDREGPIN13 0\n#define MW_GPIOC_PUPDREGPIN13 0\n#define MW_GPIOC_OUTTYPEREGPIN14 0\n#define MW_GPIOC_OUTSPEEDREGPIN14 0\n#define MW_GPIOC_PUPDREGPIN14 0\n#define MW_GPIOC_OUTTYPEREGPIN15 0\n#define MW_GPIOC_OUTSPEEDREGPIN15 0\n#define MW_GPIOC_PUPDREGPIN15 0\n#define MW_GPIOD_SHOWPINSETTING 0\n#define MW_GPIOD_OUTTYPEREGPIN0 0\n#define MW_GPIOD_OUTSPEEDREGPIN0 0\n#define MW_GPIOD_PUPDREGPIN0 0\n#define MW_GPIOD_OUTTYPEREGPIN1 0\n#define MW_GPIOD_OUTSPEEDREGPIN1 0\n#define MW_GPIOD_PUPDREGPIN1 0\n#define MW_GPIOD_OUTTYPEREGPIN2 0\n#define MW_GPIOD_OUTSPEEDREGPIN2 0\n#define MW_GPIOD_PUPDREGPIN2 0\n#define MW_GPIOD_OUTTYPEREGPIN3 0\n#define MW_GPIOD_OUTSPEEDREGPIN3 0\n#define MW_GPIOD_PUPDREGPIN3 0\n#define MW_GPIOD_OUTTYPEREGPIN4 0\n#define MW_GPIOD_OUTSPEEDREGPIN4 0\n#define MW_GPIOD_PUPDREGPIN4 0\n#define MW_GPIOD_OUTTYPEREGPIN5 0\n#define MW_GPIOD_OUTSPEEDREGPIN5 0\n#define MW_GPIOD_PUPDREGPIN5 0\n#define MW_GPIOD_OUTTYPEREGPIN6 0\n#define MW_GPIOD_OUTSPEEDREGPIN6 0\n#define MW_GPIOD_PUPDREGPIN6 0\n#define MW_GPIOD_OUTTYPEREGPIN7 0\n#define MW_GPIOD_OUTSPEEDREGPIN7 0\n#define MW_GPIOD_PUPDREGPIN7 0\n#define MW_GPIOD_OUTTYPEREGPIN8 0\n#define MW_GPIOD_OUTSPEEDREGPIN8 0\n#define MW_GPIOD_PUPDREGPIN8 0\n#define MW_GPIOD_OUTTYPEREGPIN9 0\n#define MW_GPIOD_OUTSPEEDREGPIN9 0\n#define MW_GPIOD_PUPDREGPIN9 0\n#define MW_GPIOD_OUTTYPEREGPIN10 0\n#define MW_GPIOD_OUTSPEEDREGPIN10 0\n#define MW_GPIOD_PUPDREGPIN10 0\n#define MW_GPIOD_OUTTYPEREGPIN11 0\n#define MW_GPIOD_OUTSPEEDREGPIN11 0\n#define MW_GPIOD_PUPDREGPIN11 0\n#define MW_GPIOD_OUTTYPEREGPIN12 0\n#define MW_GPIOD_OUTSPEEDREGPIN12 0\n#define MW_GPIOD_PUPDREGPIN12 0\n#define MW_GPIOD_OUTTYPEREGPIN13 0\n#define MW_GPIOD_OUTSPEEDREGPIN13 0\n#define MW_GPIOD_PUPDREGPIN13 0\n#define MW_GPIOD_OUTTYPEREGPIN14 0\n#define MW_GPIOD_OUTSPEEDREGPIN14 0\n#define MW_GPIOD_PUPDREGPIN14 0\n#define MW_GPIOD_OUTTYPEREGPIN15 0\n#define MW_GPIOD_OUTSPEEDREGPIN15 0\n#define MW_GPIOD_PUPDREGPIN15 0\n#define MW_GPIOE_SHOWPINSETTING 0\n#define MW_GPIOE_OUTTYPEREGPIN0 0\n#define MW_GPIOE_OUTSPEEDREGPIN0 0\n#define MW_GPIOE_PUPDREGPIN0 0\n#define MW_GPIOE_OUTTYPEREGPIN1 0\n#define MW_GPIOE_OUTSPEEDREGPIN1 0\n#define MW_GPIOE_PUPDREGPIN1 0\n#define MW_GPIOE_OUTTYPEREGPIN2 0\n#define MW_GPIOE_OUTSPEEDREGPIN2 0\n#define MW_GPIOE_PUPDREGPIN2 0\n#define MW_GPIOE_OUTTYPEREGPIN3 0\n#define MW_GPIOE_OUTSPEEDREGPIN3 0\n#define MW_GPIOE_PUPDREGPIN3 0\n#define MW_GPIOE_OUTTYPEREGPIN4 0\n#define MW_GPIOE_OUTSPEEDREGPIN4 0\n#define MW_GPIOE_PUPDREGPIN4 0\n#define MW_GPIOE_OUTTYPEREGPIN5 0\n#define MW_GPIOE_OUTSPEEDREGPIN5 0\n#define MW_GPIOE_PUPDREGPIN5 0\n#define MW_GPIOE_OUTTYPEREGPIN6 0\n#define MW_GPIOE_OUTSPEEDREGPIN6 0\n#define MW_GPIOE_PUPDREGPIN6 0\n#define MW_GPIOE_OUTTYPEREGPIN7 0\n#define MW_GPIOE_OUTSPEEDREGPIN7 0\n#define MW_GPIOE_PUPDREGPIN7 0\n#define MW_GPIOE_OUTTYPEREGPIN8 0\n#define MW_GPIOE_OUTSPEEDREGPIN8 0\n#define MW_GPIOE_PUPDREGPIN8 0\n#define MW_GPIOE_OUTTYPEREGPIN9 0\n#define MW_GPIOE_OUTSPEEDREGPIN9 0\n#define MW_GPIOE_PUPDREGPIN9 0\n#define MW_GPIOE_OUTTYPEREGPIN10 0\n#define MW_GPIOE_OUTSPEEDREGPIN10 0\n#define MW_GPIOE_PUPDREGPIN10 0\n#define MW_GPIOE_OUTTYPEREGPIN11 0\n#define MW_GPIOE_OUTSPEEDREGPIN11 0\n#define MW_GPIOE_PUPDREGPIN11 0\n#define MW_GPIOE_OUTTYPEREGPIN12 0\n#define MW_GPIOE_OUTSPEEDREGPIN12 0\n#define MW_GPIOE_PUPDREGPIN12 0\n#define MW_GPIOE_OUTTYPEREGPIN13 0\n#define MW_GPIOE_OUTSPEEDREGPIN13 0\n#define MW_GPIOE_PUPDREGPIN13 0\n#define MW_GPIOE_OUTTYPEREGPIN14 0\n#define MW_GPIOE_OUTSPEEDREGPIN14 0\n#define MW_GPIOE_PUPDREGPIN14 0\n#define MW_GPIOE_OUTTYPEREGPIN15 0\n#define MW_GPIOE_OUTSPEEDREGPIN15 0\n#define MW_GPIOE_PUPDREGPIN15 0\n#define MW_GPIOF_SHOWPINSETTING 0\n#define MW_GPIOF_OUTTYPEREGPIN0 0\n#define MW_GPIOF_OUTSPEEDREGPIN0 0\n#define MW_GPIOF_PUPDREGPIN0 0\n#define MW_GPIOF_OUTTYPEREGPIN1 0\n#define MW_GPIOF_OUTSPEEDREGPIN1 0\n#define MW_GPIOF_PUPDREGPIN1 0\n#define MW_GPIOF_OUTTYPEREGPIN2 0\n#define MW_GPIOF_OUTSPEEDREGPIN2 0\n#define MW_GPIOF_PUPDREGPIN2 0\n#define MW_GPIOF_OUTTYPEREGPIN3 0\n#define MW_GPIOF_OUTSPEEDREGPIN3 0\n#define MW_GPIOF_PUPDREGPIN3 0\n#define MW_GPIOF_OUTTYPEREGPIN4 0\n#define MW_GPIOF_OUTSPEEDREGPIN4 0\n#define MW_GPIOF_PUPDREGPIN4 0\n#define MW_GPIOF_OUTTYPEREGPIN5 0\n#define MW_GPIOF_OUTSPEEDREGPIN5 0\n#define MW_GPIOF_PUPDREGPIN5 0\n#define MW_GPIOF_OUTTYPEREGPIN6 0\n#define MW_GPIOF_OUTSPEEDREGPIN6 0\n#define MW_GPIOF_PUPDREGPIN6 0\n#define MW_GPIOF_OUTTYPEREGPIN7 0\n#define MW_GPIOF_OUTSPEEDREGPIN7 0\n#define MW_GPIOF_PUPDREGPIN7 0\n#define MW_GPIOF_OUTTYPEREGPIN8 0\n#define MW_GPIOF_OUTSPEEDREGPIN8 0\n#define MW_GPIOF_PUPDREGPIN8 0\n#define MW_GPIOF_OUTTYPEREGPIN9 0\n#define MW_GPIOF_OUTSPEEDREGPIN9 0\n#define MW_GPIOF_PUPDREGPIN9 0\n#define MW_GPIOF_OUTTYPEREGPIN10 0\n#define MW_GPIOF_OUTSPEEDREGPIN10 0\n#define MW_GPIOF_PUPDREGPIN10 0\n#define MW_GPIOF_OUTTYPEREGPIN11 0\n#define MW_GPIOF_OUTSPEEDREGPIN11 0\n#define MW_GPIOF_PUPDREGPIN11 0\n#define MW_GPIOF_OUTTYPEREGPIN12 0\n#define MW_GPIOF_OUTSPEEDREGPIN12 0\n#define MW_GPIOF_PUPDREGPIN12 0\n#define MW_GPIOF_OUTTYPEREGPIN13 0\n#define MW_GPIOF_OUTSPEEDREGPIN13 0\n#define MW_GPIOF_PUPDREGPIN13 0\n#define MW_GPIOF_OUTTYPEREGPIN14 0\n#define MW_GPIOF_OUTSPEEDREGPIN14 0\n#define MW_GPIOF_PUPDREGPIN14 0\n#define MW_GPIOF_OUTTYPEREGPIN15 0\n#define MW_GPIOF_OUTSPEEDREGPIN15 0\n#define MW_GPIOF_PUPDREGPIN15 0\n#define MW_GPIOG_SHOWPINSETTING 0\n#define MW_GPIOG_OUTTYPEREGPIN0 0\n#define MW_GPIOG_OUTSPEEDREGPIN0 0\n#define MW_GPIOG_PUPDREGPIN0 0\n#define MW_GPIOG_OUTTYPEREGPIN1 0\n#define MW_GPIOG_OUTSPEEDREGPIN1 0\n#define MW_GPIOG_PUPDREGPIN1 0\n#define MW_GPIOG_OUTTYPEREGPIN2 0\n#define MW_GPIOG_OUTSPEEDREGPIN2 0\n#define MW_GPIOG_PUPDREGPIN2 0\n#define MW_GPIOG_OUTTYPEREGPIN3 0\n#define MW_GPIOG_OUTSPEEDREGPIN3 0\n#define MW_GPIOG_PUPDREGPIN3 0\n#define MW_GPIOG_OUTTYPEREGPIN4 0\n#define MW_GPIOG_OUTSPEEDREGPIN4 0\n#define MW_GPIOG_PUPDREGPIN4 0\n#define MW_GPIOG_OUTTYPEREGPIN5 0\n#define MW_GPIOG_OUTSPEEDREGPIN5 0\n#define MW_GPIOG_PUPDREGPIN5 0\n#define MW_GPIOG_OUTTYPEREGPIN6 0\n#define MW_GPIOG_OUTSPEEDREGPIN6 0\n#define MW_GPIOG_PUPDREGPIN6 0\n#define MW_GPIOG_OUTTYPEREGPIN7 0\n#define MW_GPIOG_OUTSPEEDREGPIN7 0\n#define MW_GPIOG_PUPDREGPIN7 0\n#define MW_GPIOG_OUTTYPEREGPIN8 0\n#define MW_GPIOG_OUTSPEEDREGPIN8 0\n#define MW_GPIOG_PUPDREGPIN8 0\n#define MW_GPIOG_OUTTYPEREGPIN9 0\n#define MW_GPIOG_OUTSPEEDREGPIN9 0\n#define MW_GPIOG_PUPDREGPIN9 0\n#define MW_GPIOG_OUTTYPEREGPIN10 0\n#define MW_GPIOG_OUTSPEEDREGPIN10 0\n#define MW_GPIOG_PUPDREGPIN10 0\n#define MW_GPIOG_OUTTYPEREGPIN11 0\n#define MW_GPIOG_OUTSPEEDREGPIN11 0\n#define MW_GPIOG_PUPDREGPIN11 0\n#define MW_GPIOG_OUTTYPEREGPIN12 0\n#define MW_GPIOG_OUTSPEEDREGPIN12 0\n#define MW_GPIOG_PUPDREGPIN12 0\n#define MW_GPIOG_OUTTYPEREGPIN13 0\n#define MW_GPIOG_OUTSPEEDREGPIN13 0\n#define MW_GPIOG_PUPDREGPIN13 0\n#define MW_GPIOG_OUTTYPEREGPIN14 0\n#define MW_GPIOG_OUTSPEEDREGPIN14 0\n#define MW_GPIOG_PUPDREGPIN14 0\n#define MW_GPIOG_OUTTYPEREGPIN15 0\n#define MW_GPIOG_OUTSPEEDREGPIN15 0\n#define MW_GPIOG_PUPDREGPIN15 0\n#define MW_GPIOH_SHOWPINSETTING 0\n#define MW_GPIOH_OUTTYPEREGPIN0 0\n#define MW_GPIOH_OUTSPEEDREGPIN0 0\n#define MW_GPIOH_PUPDREGPIN0 0\n#define MW_GPIOH_OUTTYPEREGPIN1 0\n#define MW_GPIOH_OUTSPEEDREGPIN1 0\n#define MW_GPIOH_PUPDREGPIN1 0\n#define MW_GPIOH_OUTTYPEREGPIN2 0\n#define MW_GPIOH_OUTSPEEDREGPIN2 0\n#define MW_GPIOH_PUPDREGPIN2 0\n#define MW_GPIOH_OUTTYPEREGPIN3 0\n#define MW_GPIOH_OUTSPEEDREGPIN3 0\n#define MW_GPIOH_PUPDREGPIN3 0\n#define MW_GPIOH_OUTTYPEREGPIN4 0\n#define MW_GPIOH_OUTSPEEDREGPIN4 0\n#define MW_GPIOH_PUPDREGPIN4 0\n#define MW_GPIOH_OUTTYPEREGPIN5 0\n#define MW_GPIOH_OUTSPEEDREGPIN5 0\n#define MW_GPIOH_PUPDREGPIN5 0\n#define MW_GPIOH_OUTTYPEREGPIN6 0\n#define MW_GPIOH_OUTSPEEDREGPIN6 0\n#define MW_GPIOH_PUPDREGPIN6 0\n#define MW_GPIOH_OUTTYPEREGPIN7 0\n#define MW_GPIOH_OUTSPEEDREGPIN7 0\n#define MW_GPIOH_PUPDREGPIN7 0\n#define MW_GPIOH_OUTTYPEREGPIN8 0\n#define MW_GPIOH_OUTSPEEDREGPIN8 0\n#define MW_GPIOH_PUPDREGPIN8 0\n#define MW_GPIOH_OUTTYPEREGPIN9 0\n#define MW_GPIOH_OUTSPEEDREGPIN9 0\n#define MW_GPIOH_PUPDREGPIN9 0\n#define MW_GPIOH_OUTTYPEREGPIN10 0\n#define MW_GPIOH_OUTSPEEDREGPIN10 0\n#define MW_GPIOH_PUPDREGPIN10 0\n#define MW_GPIOH_OUTTYPEREGPIN11 0\n#define MW_GPIOH_OUTSPEEDREGPIN11 0\n#define MW_GPIOH_PUPDREGPIN11 0\n#define MW_GPIOH_OUTTYPEREGPIN12 0\n#define MW_GPIOH_OUTSPEEDREGPIN12 0\n#define MW_GPIOH_PUPDREGPIN12 0\n#define MW_GPIOH_OUTTYPEREGPIN13 0\n#define MW_GPIOH_OUTSPEEDREGPIN13 0\n#define MW_GPIOH_PUPDREGPIN13 0\n#define MW_GPIOH_OUTTYPEREGPIN14 0\n#define MW_GPIOH_OUTSPEEDREGPIN14 0\n#define MW_GPIOH_PUPDREGPIN14 0\n#define MW_GPIOH_OUTTYPEREGPIN15 0\n#define MW_GPIOH_OUTSPEEDREGPIN15 0\n#define MW_GPIOH_PUPDREGPIN15 0\n#define MW_GPIOI_SHOWPINSETTING 0\n#define MW_GPIOI_OUTTYPEREGPIN0 0\n#define MW_GPIOI_OUTSPEEDREGPIN0 0\n#define MW_GPIOI_PUPDREGPIN0 0\n#define MW_GPIOI_OUTTYPEREGPIN1 0\n#define MW_GPIOI_OUTSPEEDREGPIN1 0\n#define MW_GPIOI_PUPDREGPIN1 0\n#define MW_GPIOI_OUTTYPEREGPIN2 0\n#define MW_GPIOI_OUTSPEEDREGPIN2 0\n#define MW_GPIOI_PUPDREGPIN2 0\n#define MW_GPIOI_OUTTYPEREGPIN3 0\n#define MW_GPIOI_OUTSPEEDREGPIN3 0\n#define MW_GPIOI_PUPDREGPIN3 0\n#define MW_GPIOI_OUTTYPEREGPIN4 0\n#define MW_GPIOI_OUTSPEEDREGPIN4 0\n#define MW_GPIOI_PUPDREGPIN4 0\n#define MW_GPIOI_OUTTYPEREGPIN5 0\n#define MW_GPIOI_OUTSPEEDREGPIN5 0\n#define MW_GPIOI_PUPDREGPIN5 0\n#define MW_GPIOI_OUTTYPEREGPIN6 0\n#define MW_GPIOI_OUTSPEEDREGPIN6 0\n#define MW_GPIOI_PUPDREGPIN6 0\n#define MW_GPIOI_OUTTYPEREGPIN7 0\n#define MW_GPIOI_OUTSPEEDREGPIN7 0\n#define MW_GPIOI_PUPDREGPIN7 0\n#define MW_GPIOI_OUTTYPEREGPIN8 0\n#define MW_GPIOI_OUTSPEEDREGPIN8 0\n#define MW_GPIOI_PUPDREGPIN8 0\n#define MW_GPIOI_OUTTYPEREGPIN9 0\n#define MW_GPIOI_OUTSPEEDREGPIN9 0\n#define MW_GPIOI_PUPDREGPIN9 0\n#define MW_GPIOI_OUTTYPEREGPIN10 0\n#define MW_GPIOI_OUTSPEEDREGPIN10 0\n#define MW_GPIOI_PUPDREGPIN10 0\n#define MW_GPIOI_OUTTYPEREGPIN11 0\n#define MW_GPIOI_OUTSPEEDREGPIN11 0\n#define MW_GPIOI_PUPDREGPIN11 0\n#define MW_GPIOI_OUTTYPEREGPIN12 0\n#define MW_GPIOI_OUTSPEEDREGPIN12 0\n#define MW_GPIOI_PUPDREGPIN12 0\n#define MW_GPIOI_OUTTYPEREGPIN13 0\n#define MW_GPIOI_OUTSPEEDREGPIN13 0\n#define MW_GPIOI_PUPDREGPIN13 0\n#define MW_GPIOI_OUTTYPEREGPIN14 0\n#define MW_GPIOI_OUTSPEEDREGPIN14 0\n#define MW_GPIOI_PUPDREGPIN14 0\n#define MW_GPIOI_OUTTYPEREGPIN15 0\n#define MW_GPIOI_OUTSPEEDREGPIN15 0\n#define MW_GPIOI_PUPDREGPIN15 0\n#define MW_DATAVERSION 2016.02\n#define MW_STM32_DIGITALPORTWRITE_ID 106\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"SysTickScheduler.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* SysTick scheduler\n * \n * Copyright 2013-2020 The MathWorks, Inc.\n */\n \n#include \"MW_target_hardware_resources.h\"\n\nunsigned long schdl_counter;\nunsigned long schdl_counter_max;\n\nextern volatile uint32_t taskToSchedule;\n\nstatic void SysTick_Isr(void)\n{\n    __DSB();\n    __ISB();\n\t\n\tif (schdl_counter >= schdl_counter_max)\n\t{\n\t\tschdl_counter = 0;\n\t}\n\t\n    if (0 == schdl_counter++)\t/* Compare with zero before increment */\n\t{\n\t\t/* The rt_OneStep() function expects interrupts to be disabled. \n           Hence disable interrupt before rt_OneStep(). */\n        __disable_irq();\n        rt_OneStep();\n        /* The rt_OneStep() function disables interrupt. \n           Hence enable interrupt immediately after rt_OneStep(). */\n        __enable_irq();\n\t}\n}\n\n#if (__CORTEX_M >= 3)\n    void SysTick_Handler(){\n    SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;\n}\n#else\nMW_RENTRANT_ISR_FUNCTION_BEGIN(SysTick_Handler, -1)\n    MW_CALL_ISR_FUNCTION(SysTick_Isr);\nMW_RENTRANT_ISR_FUNCTION_END()\n#endif\n\nvoid ARMCM_SysTick_Config(float modelBaseRate)\n{\n#if !defined(MW_DONT_USE_SYSTICK)    \n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n\t/* SysTick Scheduler is selected */\n\tunsigned long tick_counter;\n\t\n\ttick_counter = (unsigned long)(SystemCoreClock * modelBaseRate);\n\t\n\tif (tick_counter > SysTick_LOAD_RELOAD_Msk)\n\t{\n\t\tschdl_counter_max = (unsigned long)((float)tick_counter / (float)SysTick_LOAD_RELOAD_Msk) + 1;\n\t\tSysTick_Config(tick_counter/schdl_counter_max);\t\t\n\t}\n\telse\n\t{\n\t\tschdl_counter_max = 0;\n\t\tSysTick_Config(tick_counter);\n\t}\n\t\n\tschdl_counter = 0;\n\t\n\t/* Set the SysTick priority */\n\t#ifdef MW_SCHEDULER_PRIORITY\n\t\tNVIC_SetPriority((IRQn_Type)(-1), MW_SCHEDULER_PRIORITY);\n\t#endif\n    #if (__CORTEX_M >= 3)\n        taskToSchedule = (uint32_t) SysTick_Isr;\n    #endif\n#endif\n#endif\n    NVIC_SetPriority((IRQn_Type)(-5), MW_MAX_PRIORITY_VALUE);\n    NVIC_SetPriority((IRQn_Type)(-2), MW_MAX_PRIORITY_VALUE);\n}\n\nvoid ARMCM_SysTick_Stop(void)\n{\n#if !defined(MW_DONT_USE_SYSTICK)    \n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n\t/* SysTick Scheduler is Stopped */\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;\n#endif\n#endif\n}"},{"name":"blapp_support.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\stm32f4discovery\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2018 The MathWorks, Inc. */\n\n\n#include \"blapp_support.h\"\n\n#ifdef MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT\n\n#if MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT != 1 ||  MW_RUNTIME_BOOTLOADERCOMPATIBLEOS == 0\n\nvoid bootloaderBackgroundTask(void)\n{\n}\nvoid bootloaderInit(void)\n{\n}\n\n#else\n\nextern uint8_t __START_ROM_ADDR;\nextern uint8_t __FINAL_APP_POINTER;\n__attribute__ ((section (\"sFINALFLASHPTR\")))  uint32_t APPDATAPOINTER = (uint32_t)&__FINAL_APP_POINTER;\n__attribute__ ((section (\"sFINALAPPDATA\")))  uint32_t APPDATACOMPLETED = VAL_ROM_LAST;\n\n#if MW_RUNTIME_BOOTLOADERAPPLICATIONHASCOM == 0\n\t \nvoid (*MyUARTConfig)( void );\nvoid (*MyUARTISR)( void );\nvoid (*MyUARTIDLETASK)( void );\n__attribute__ ((section (\"sCOMMOWNERromMSG\")))  uint32_t COMMownerROMmsg = VAL_ROM_APP_ComCtrl_BL;\n#else\n__attribute__ ((section (\"sCOMMOWNERromMSG\")))  uint32_t COMMownerROMmsg = VAL_ROM_APP_ComCtrl_APP;\n#endif\n \n uint8_t OkforMemServ;\n\n \n//UART_HandleTypeDef \tUARTHandle;\n \n\n#if MW_RUNTIME_BOOTLOADERAPPLICATIONHASCOM == 0\nvoid USART2_IRQHandler(void)\n{\n\tMyUARTISR();\n}\n#endif\n\n void bootloaderInit(void)\n {\n\tuint32_t u32_L_tmp;\n\tu32_L_tmp=APPDATACOMPLETED+1;\n\tu32_L_tmp=APPDATAPOINTER+u32_L_tmp;\n\tu32_L_tmp=COMMownerROMmsg+u32_L_tmp;\n\tSCB->VTOR=(uint32_t )&__START_ROM_ADDR;//set vector table to start of ROM address.\n\t__set_PRIMASK(0);//Enable interrupts\n\n\t#if MW_RUNTIME_BOOTLOADERAPPLICATIONHASCOM == 0\t\n\tu32_L_tmp=*(uint32_t *)ADDR_RAM_MSG_VALIDATION;\n\tif (u32_L_tmp == VAL_RAM_MSG_VALIDATION)\n\t{\n\t\tu32_L_tmp=*(uint32_t *)ADDR_UART_CONFIG;\n\t\tMyUARTConfig=(void (*)(void))(u32_L_tmp+1);\n\t\t\n\t\tu32_L_tmp=*(uint32_t *)ADDR_UART_ISR;\n\t\tMyUARTISR=(void (*)(void))(u32_L_tmp+1);\n\t\t//USART2_IRQHandler=MyUARTISR;\n\t\tu32_L_tmp=*(uint32_t *)ADDR_UART_IDLETASK;\n\t\tMyUARTIDLETASK=(void (*)(void))(u32_L_tmp+1);\n\t\tOkforMemServ=1;\n\t\tMyUARTConfig();\n\t}\n\telse\n\t{\n\t\tOkforMemServ=0;\n\t}\n\t#endif\n }\nvoid Error_Handler(void)\n{\n  while(1)\n  {\n  }\n}\nvoid bootloaderBackgroundTask(void)\n{\n\n\t#if MW_RUNTIME_BOOTLOADERAPPLICATIONHASCOM == 0\n\tif (OkforMemServ == 1)\n\t{\n\t\tMyUARTIDLETASK();\n\t}\n\t#endif\n\n}\n#endif\n#endif\n\n\n \n"},{"name":"m3m4m4f_multitasking.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Wrapper for Multi tasking.\n * \n * Copyright 2013-2020 The MathWorks, Inc.\n */\n\n\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#include \"MW_target_hardware_resources.h\"\n#endif\n\n#ifndef __NVIC_PRIO_BITS\n#error \"__NVIC_PRIO_BITS is undefined.  The __NVIC_PRIO_BITS is defined in hardware definition header file.\"\n#endif\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\nvolatile uint32_t taskToSchedule;\n\n__attribute__ ((naked,aligned(4))) void PendSV_Handler() {\n    __asm volatile (\n    \"   MRS R0, APSR                            \\n\"\n    \"   PUSH {R0, LR}                           \\n\"\n    \"   MRS R0, BASEPRI                         \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST LR, #0x10                           \\n\"\n    \"   IT EQ                                   \\n\"\n    \"   VMOVEQ S0, S0                           \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   LDR R0, =taskToSchedule                 \\n\"\n    \"   LDR R0, [R0]                            \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    \"   SUB SP, SP, #0x20                       \\n\"\n    \"   ADR R0,Call_isr_routine_in_thread_mode \\n\"\n    \"   STR R0,[SP, #24]                        \\n\"\n    \"   MOV R0,#0x01000000                      \\n\"\n    \"   STR R0,[SP, #28]                        \\n\"\n    \"   MVN R0,#0x06                            \\n\"\n    \"   MOV LR, R0                              \\n\"\n    \"   BX LR                                   \\n\"\n    \"Call_isr_routine_in_thread_mode:           \\n\"\n    \"   POP {R0, R1}                            \\n\"\n    \"   BLX R0                                  \\n\"\n    \"   ISB                                     \\n\"\n    \"   SVC #0                                  \\n\"\n    \"Unknown_Execution:                         \\n\"\n    \"   B Unknown_Execution                     \\n\"\n    );\n}\n\n/* SVC Interrupt service routine to restore the context: SVC_Handler*/\n__attribute__ ((naked,aligned(4))) void SVC_Handler(void) {\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST  LR, #0x10      \\n\"\n    \"   IT EQ               \\n\"\n    \"   VMOVEQ.F32 S0, S0   \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   TST LR, #0x4            \\n\"\n    \"   ITE EQ                  \\n\"\n    \"   MRSEQ R0, MSP           \\n\"\n    \"   MRSNE R0, PSP           \\n\"\n    \"   LDR R1, [R0, #24]       \\n\"\n    \"   LDRB R0, [R1, #-2]      \\n\"\n    \"   CBZ R0, svc_service_0   \\n\"\n    \"   CMP R0, #1              \\n\"\n    \"   BEQ svc_service_1       \\n\"\n    \"   B Unknown_SVC_Request   \\n\"\n    \"svc_service_0:             \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n     __asm volatile (\n    \"   TST LR, #0x10       \\n\"\n    \"   ITE EQ              \\n\"\n    \"   ADDEQ SP, SP, #104  \\n\"\n    \"   ADDNE SP, SP, #32   \\n\"\n     );\n#else\n     __asm volatile (\"     ADD SP, SP, #32\");\n#endif\n     __asm volatile (\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR BASEPRI, R0           \\n\"\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR APSR_nzcvq, R0        \\n\"\n    \"     BX R1                     \\n\"\n    \"Unknown_SVC_Request:           \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    \"svc_service_1:                 \\n\"\n    \"     MOVW R1, #0x0000ED14      \\n\"\n    \"     MOVT R1, #0xE000          \\n\"\n    \"     LDR R2,[R1]               \\n\"\n    \"     ORR R2, #1                \\n\"\n    \"     STR R2,[R1]               \\n\"\n    \"     BX LR                     \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    );\n}\n\n/* LocalWords:  NVIC PRIO TST VMOVEQ ADR isr MOV MVNS asm cpsie chaing arival VMOV MVN\n * LocalWords:  BLX ISB SVC ITE MRSEQ MSP MRSNE PSP LDR LDRB CBZ svc CMP BEQ\n * LocalWords:  ADDEQ ADDNE MSR BASEPRI xff APSR nzcvq MOVW MOVT\n */\n"},{"name":"startup_stm32f4xx.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\stm32f4discovery\\src","tag":"","groupDisplay":"Other files","code":"/* GNU GCC startup file for STM32F4xx*/\n\n/* Copyright 2013-2020 The MathWorks, Inc. */\n#define __STARTUP_STM32F4XX_C__\n#include \"startup_stm32f4xx.h\"\n\nstatic void Default_Handler(void);\n\n/* Define stack: 8Kb base + extra */\n#if defined(__GNUC__) && !defined(MW_ARM_CLANG)\n\t\n\t__attribute__ ((section(\".co_stack\")))\n\tunsigned long pulStack[__STACK_SIZE + (((STACK_SIZE>>2) + 7) & ~7)];\n\t\n#elif defined(__GNUC__) && defined(MW_ARM_CLANG)\n\n\textern unsigned long Image$$ARM_LIB_STACK$$ZI$$Limit;\n\tconst unsigned long pulStack = (unsigned long) &Image$$ARM_LIB_STACK$$ZI$$Limit;\n\tvoid __main();\n\t\n#endif\n\n/* ISR vector table */\n__attribute__ ((section(\".vectors\")))\nvoid (* const g_pfnVectors[])(void) =\n{\n\n#if defined(__GNUC__) && !defined(MW_ARM_CLANG)\n  (void (*)(void))((unsigned long)pulStack + sizeof(pulStack)),\n#elif defined(__GNUC__) && defined(MW_ARM_CLANG)\n\t(void (*)(void)) (pulStack),\n#endif\t\n\n  Reset_Handler,\n  NMI_Handler,\n  HardFault_Handler,\n  MemManage_Handler,\n  BusFault_Handler,\n  UsageFault_Handler,\n  0,  /* Reserved */\n  0,\n  0,\n  0,                   \n  SVC_Handler,               \n  DebugMon_Handler,          \n  0, /* Reserved */                       \n  PendSV_Handler,\n  SysTick_Handler,\n  \n  /* Peripheral exceptions */\n  WWDG_IRQHandler,           \n  PVD_IRQHandler,            \n  TAMP_STAMP_IRQHandler,     \n  RTC_WKUP_IRQHandler,       \n  FLASH_IRQHandler,          \n  RCC_IRQHandler  ,          \n  EXTI0_IRQHandler,          \n  EXTI1_IRQHandler,          \n  EXTI2_IRQHandler,          \n  EXTI3_IRQHandler,          \n  EXTI4_IRQHandler,          \n  DMA1_Stream0_IRQHandler,   \n  DMA1_Stream1_IRQHandler,   \n  DMA1_Stream2_IRQHandler,   \n  DMA1_Stream3_IRQHandler,   \n  DMA1_Stream4_IRQHandler,   \n  DMA1_Stream5_IRQHandler,   \n  DMA1_Stream6_IRQHandler,   \n  ADC_IRQHandler,            \n  CAN1_TX_IRQHandler,        \n  CAN1_RX0_IRQHandler,       \n  CAN1_RX1_IRQHandler,       \n  CAN1_SCE_IRQHandler,       \n  EXTI9_5_IRQHandler,        \n  TIM1_BRK_TIM9_IRQHandler,  \n  TIM1_UP_TIM10_IRQHandler,  \n  TIM1_TRG_COM_TIM11_IRQHandler,\n  TIM1_CC_IRQHandler,        \n  TIM2_IRQHandler,           \n  TIM3_IRQHandler,           \n  TIM4_IRQHandler,           \n  I2C1_EV_IRQHandler,        \n  I2C1_ER_IRQHandler,        \n  I2C2_EV_IRQHandler,        \n  I2C2_ER_IRQHandler,        \n  SPI1_IRQHandler,           \n  SPI2_IRQHandler,           \n  USART1_IRQHandler,         \n  USART2_IRQHandler,         \n  USART3_IRQHandler,         \n  EXTI15_10_IRQHandler,      \n  RTC_Alarm_IRQHandler,      \n  OTG_FS_WKUP_IRQHandler,    \n  TIM8_BRK_TIM12_IRQHandler, \n  TIM8_UP_TIM13_IRQHandler,  \n  TIM8_TRG_COM_TIM14_IRQHandler,\n  TIM8_CC_IRQHandler,        \n  DMA1_Stream7_IRQHandler,   \n  FSMC_IRQHandler,           \n  SDIO_IRQHandler,           \n  TIM5_IRQHandler,           \n  SPI3_IRQHandler,           \n  UART4_IRQHandler,          \n  UART5_IRQHandler,          \n  TIM6_DAC_IRQHandler,       \n  TIM7_IRQHandler,           \n  DMA2_Stream0_IRQHandler,   \n  DMA2_Stream1_IRQHandler,   \n  DMA2_Stream2_IRQHandler,   \n  DMA2_Stream3_IRQHandler,   \n  DMA2_Stream4_IRQHandler,   \n  ETH_IRQHandler,            \n  ETH_WKUP_IRQHandler,       \n  CAN2_TX_IRQHandler,        \n  CAN2_RX0_IRQHandler,       \n  CAN2_RX1_IRQHandler,       \n  CAN2_SCE_IRQHandler,       \n  OTG_FS_IRQHandler,         \n  DMA2_Stream5_IRQHandler,   \n  DMA2_Stream6_IRQHandler,   \n  DMA2_Stream7_IRQHandler,   \n  USART6_IRQHandler,         \n  I2C3_EV_IRQHandler,        \n  I2C3_ER_IRQHandler,        \n  OTG_HS_EP1_OUT_IRQHandler, \n  OTG_HS_EP1_IN_IRQHandler,  \n  OTG_HS_WKUP_IRQHandler,    \n  OTG_HS_IRQHandler,         \n  DCMI_IRQHandler,           \n  CRYP_IRQHandler,           \n  HASH_RNG_IRQHandler,       \n  FPU_IRQHandler \n};\n\n\n/* Startup routine */\nvoid Default_ResetHandler(void)\n{\n#if defined(__GNUC__) && !defined(MW_ARM_CLANG)\n  /* Initialize data and bss */\n  unsigned long *pulSrc, *pulDest;\n\n  /* Copy the data segment initializers from flash to SRAM */\n  pulSrc = &_sidata;\n\n  for(pulDest = &_sdata; pulDest < &_edata; ) {\n      *(pulDest++) = *(pulSrc++);\n  }\n  \n  \n  /* Clear .bss */\n  __asm(\"  ldr     r0, =_sbss\\n\"\n        \"  ldr     r1, =_ebss\\n\"\n        \"  mov     r2, #0\\n\"\n        \"  .thumb_func\\n\"\n        \"zero_loop:\\n\"\n        \"    cmp     r0, r1\\n\"\n        \"    it      lt\\n\"\n        \"    strlt   r2, [r0], #4\\n\"\n        \"    blt     zero_loop\");\n#endif\n\t\n#ifndef __NO_SYSTEM_INIT\n  /* Call CMSIS system initialization code */\n  SystemInit();\n#endif\n  \n  /* Branch to main */\n#ifndef __START\n#define __START main\n#endif\n\n  __START();\n}\n\n/* Default interrupt handler */\nstatic void Default_Handler(void)\n{\n\t/* Go into an infinite loop. */\n\twhile (1)\n\t{\n\t}\n}\n\n/* Map all exception handlers to the default handler */\n#pragma weak Reset_Handler = Default_ResetHandler\n#pragma weak NMI_Handler = Default_Handler\n#pragma weak HardFault_Handler = Default_Handler\n#pragma weak MemManage_Handler = Default_Handler\n#pragma weak BusFault_Handler = Default_Handler\n#pragma weak UsageFault_Handler = Default_Handler\n#pragma weak SVC_Handler = Default_Handler\n#pragma weak DebugMon_Handler = Default_Handler\n#pragma weak PendSV_Handler = Default_Handler\n#pragma weak SysTick_Handler = Default_Handler\n#pragma weak WWDG_IRQHandler = Default_Handler\n#pragma weak PVD_IRQHandler = Default_Handler\n#pragma weak TAMP_STAMP_IRQHandler = Default_Handler\n#pragma weak RTC_WKUP_IRQHandler = Default_Handler\n#pragma weak FLASH_IRQHandler = Default_Handler\n#pragma weak RCC_IRQHandler = Default_Handler\n#pragma weak EXTI0_IRQHandler = Default_Handler\n#pragma weak EXTI1_IRQHandler = Default_Handler\n#pragma weak EXTI2_IRQHandler = Default_Handler\n#pragma weak EXTI3_IRQHandler = Default_Handler\n#pragma weak EXTI4_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream0_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream1_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream2_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream3_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream4_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream5_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream6_IRQHandler = Default_Handler\n#pragma weak ADC_IRQHandler = Default_Handler\n#pragma weak CAN1_TX_IRQHandler = Default_Handler\n#pragma weak CAN1_RX0_IRQHandler = Default_Handler\n#pragma weak CAN1_RX1_IRQHandler = Default_Handler\n#pragma weak CAN1_SCE_IRQHandler = Default_Handler\n#pragma weak EXTI9_5_IRQHandler = Default_Handler\n#pragma weak TIM1_BRK_TIM9_IRQHandler = Default_Handler\n#pragma weak TIM1_UP_TIM10_IRQHandler = Default_Handler\n#pragma weak TIM1_TRG_COM_TIM11_IRQHandler = Default_Handler\n#pragma weak TIM1_CC_IRQHandler = Default_Handler\n#pragma weak TIM2_IRQHandler = Default_Handler\n#pragma weak TIM3_IRQHandler = Default_Handler\n#pragma weak TIM4_IRQHandler = Default_Handler\n#pragma weak I2C1_EV_IRQHandler = Default_Handler\n#pragma weak I2C1_ER_IRQHandler = Default_Handler\n#pragma weak I2C2_EV_IRQHandler = Default_Handler\n#pragma weak I2C2_ER_IRQHandler = Default_Handler\n#pragma weak SPI1_IRQHandler = Default_Handler\n#pragma weak SPI2_IRQHandler = Default_Handler\n#pragma weak USART1_IRQHandler = Default_Handler\n#pragma weak USART2_IRQHandler = Default_Handler\n#pragma weak USART3_IRQHandler = Default_Handler\n#pragma weak EXTI15_10_IRQHandler = Default_Handler\n#pragma weak RTC_Alarm_IRQHandler = Default_Handler\n#pragma weak OTG_FS_WKUP_IRQHandler = Default_Handler\n#pragma weak TIM8_BRK_TIM12_IRQHandler = Default_Handler\n#pragma weak TIM8_UP_TIM13_IRQHandler = Default_Handler\n#pragma weak TIM8_TRG_COM_TIM14_IRQHandler = Default_Handler\n#pragma weak TIM8_CC_IRQHandler = Default_Handler\n#pragma weak DMA1_Stream7_IRQHandler = Default_Handler\n#pragma weak FSMC_IRQHandler = Default_Handler\n#pragma weak SDIO_IRQHandler = Default_Handler\n#pragma weak TIM5_IRQHandler = Default_Handler\n#pragma weak SPI3_IRQHandler = Default_Handler\n#pragma weak UART4_IRQHandler = Default_Handler\n#pragma weak UART5_IRQHandler = Default_Handler\n#pragma weak TIM6_DAC_IRQHandler = Default_Handler\n#pragma weak TIM7_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream0_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream1_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream2_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream3_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream4_IRQHandler = Default_Handler\n#pragma weak ETH_IRQHandler = Default_Handler\n#pragma weak ETH_WKUP_IRQHandler = Default_Handler\n#pragma weak CAN2_TX_IRQHandler = Default_Handler\n#pragma weak CAN2_RX0_IRQHandler = Default_Handler\n#pragma weak CAN2_RX1_IRQHandler = Default_Handler\n#pragma weak CAN2_SCE_IRQHandler = Default_Handler\n#pragma weak OTG_FS_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream5_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream6_IRQHandler = Default_Handler\n#pragma weak DMA2_Stream7_IRQHandler = Default_Handler\n#pragma weak USART6_IRQHandler = Default_Handler\n#pragma weak I2C3_EV_IRQHandler = Default_Handler\n#pragma weak I2C3_ER_IRQHandler = Default_Handler\n#pragma weak OTG_HS_EP1_OUT_IRQHandler = Default_Handler\n#pragma weak OTG_HS_EP1_IN_IRQHandler = Default_Handler\n#pragma weak OTG_HS_WKUP_IRQHandler = Default_Handler\n#pragma weak OTG_HS_IRQHandler = Default_Handler\n#pragma weak DCMI_IRQHandler = Default_Handler\n#pragma weak CRYP_IRQHandler = Default_Handler\n#pragma weak HASH_RNG_IRQHandler = Default_Handler\n#pragma weak FPU_IRQHandler = Default_Handler\n/* EOF */\n"},{"name":"stm32f4xx_init_board.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\stm32f4discovery\\src","tag":"","groupDisplay":"Other files","code":"/* Wrapper header for STM32F4-Discovery \n * \n * Copyright 2013 The MathWorks, Inc.\n */\n#include \"stm32f4discovery_wrapper.h\"\n\nvoid stm32f4xx_init_board(void)\n{\n\t/* Enable double word stack alignment */\n\tSCB->CCR |= SCB_CCR_STKALIGN_Msk;\n\n\t#if MW_MULTI_TASKING_MODE == 1\n    /* Set the interrupt priority at highest */\n    NVIC_SetPriority(SVCall_IRQn, 0x0);\n    #endif\n  \n    #if defined(MW_ENABLE_CLOCK_TO_I2S) && (MW_ENABLE_CLOCK_TO_I2S == 1)\n    MW_I2S_Clock_config((uint32_t)MW_I2S_CLOCK_PLLN, (uint32_t)MW_I2S_CLOCK_PLLR);\n    #endif\n}\n"},{"name":"syscalls_stm32f4xx.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\stm32f4discovery\\src","tag":"","groupDisplay":"Other files","code":"/*\n * STM32F4-Discovery system calls\n *\n * Copyright 2013-2016 The MathWorks, Inc.\n */\n#include <sys/stat.h>\n#include <errno.h>\n\n#undef errno\nextern int errno;\n \n\n__attribute__((weak)) int _close(int file) \n{ \n    return -1; \n}\n\n__attribute__((weak)) int _fstat(int file, struct stat *st) \n{\n    st->st_mode = S_IFCHR;\n    return 0;\n}\n\n__attribute__((weak)) int _isatty(int file) \n{ \n    return 1; \n}\n\n__attribute__((weak)) int _lseek(int file, int ptr, int dir) \n{ \n    return 0; \n}\n\n__attribute__((weak)) int _open(const char *name, int flags, int mode) \n{ \n    return -1; \n}\n\n__attribute__((weak)) int _read(int file, char *ptr, int len) \n{\n    return 0;\n}\n\n__attribute__((weak)) void _exit(int status)\n{\n\twhile(1);\n}\n\n/* Used for malloc() */\nextern unsigned int _sheap;  /* Start of HEAP */\nextern unsigned int _eheap;  /* End of HEAP  */\ncaddr_t heap_end = 0;\n__attribute__((weak)) caddr_t _sbrk(int incr) {\n    caddr_t prev_heap_end;\n    caddr_t tmp;\n    \n    if (heap_end == 0) {\n        heap_end = (caddr_t) &_sheap;\n    }\n    prev_heap_end = heap_end;\n    \n    /* Always align to an eight byte boundary */\n    tmp = (caddr_t) (((unsigned int)heap_end + incr + 7) & ~7);\n    if (tmp >= ((caddr_t)&_eheap)) {\n        /* No more HEAP */\n        errno = ENOMEM;\n        return (caddr_t)-1;        \n    }\n    heap_end = tmp;\n    \n    return prev_heap_end;\n}\n\n__attribute__((weak)) int _write(int file, char *ptr, int len) \n{\n    return len;\n}\n\n__attribute__((weak)) int _unlink(char *ptr)\n{\n    (void)ptr;\n    return (1);\n}"},{"name":"system_stm32f4xx.c","type":"source","group":"legacy","path":"C:\\Users\\eahil\\Documents\\GitHub\\smart-cpr-algo\\src\\cpr-algo\\test_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\stm32f4discovery\\src","tag":"","groupDisplay":"Other files","code":"/**\n  *=============================================================================\n  *        Supported STM32F40xx/41xx/427x/437x devices\n  *-----------------------------------------------------------------------------\n  *        System Clock source                    | PLL (HSE)\n  *-----------------------------------------------------------------------------\n  *        SYSCLK(Hz)                             | 168000000\n  *-----------------------------------------------------------------------------\n  *        HCLK(Hz)                               | 168000000\n  *-----------------------------------------------------------------------------\n  *        AHB Prescaler                          | 1\n  *-----------------------------------------------------------------------------\n  *        APB1 Prescaler                         | 4\n  *-----------------------------------------------------------------------------\n  *        APB2 Prescaler                         | 2\n  *-----------------------------------------------------------------------------\n  *        HSE Frequency(Hz)                      | 8000000\n  *-----------------------------------------------------------------------------\n  *        PLL_M                                  | 8\n  *-----------------------------------------------------------------------------\n  *        PLL_N                                  | 336\n  *-----------------------------------------------------------------------------\n  *        PLL_P                                  | 2\n  *-----------------------------------------------------------------------------\n  *        PLL_Q                                  | 7\n  *-----------------------------------------------------------------------------\n  *        PLLI2S_N                               | NA\n  *-----------------------------------------------------------------------------\n  *        PLLI2S_R                               | NA\n  *-----------------------------------------------------------------------------\n  *        I2S input clock                        | NA\n  *-----------------------------------------------------------------------------\n  *        VDD(V)                                 | 3.3\n  *-----------------------------------------------------------------------------\n  *        Main regulator output voltage          | Scale1 mode\n  *-----------------------------------------------------------------------------\n  *        Flash Latency(WS)                      | 5\n  *-----------------------------------------------------------------------------\n  *        Prefetch Buffer                        | OFF\n  *-----------------------------------------------------------------------------\n  *        Instruction cache                      | ON\n  *-----------------------------------------------------------------------------\n  *        Data cache                             | ON\n  *-----------------------------------------------------------------------------\n  *=============================================================================\n  */\n\n#include \"stm32f4xx.h\"\n\n/* External SRAM and Vector table configuration */\n\n/* Uncomment the following line if you need to use external SRAM mounted\n     on STM324xG_EVAL/STM324x7I_EVAL board as data memory  */\n/* #define DATA_IN_ExtSRAM */\n\n/* Uncomment the following line if you need to relocate your vector Table in\n     Internal SRAM. */\n/* #define VECT_TAB_SRAM */\n#define VECT_TAB_OFFSET  0x00 /* Vector Table base offset field. \n                                   This value must be a multiple of 0x200. */\n\n\n/* PLL configuration parameters */\n/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */\n#ifndef PLL_M\n#define PLL_M      8\n#endif\n\n#ifndef PLL_N\n#define PLL_N      336\n#endif\n\n/* SYSCLK = PLL_VCO / PLL_P */\n#ifndef PLL_P\n#define PLL_P      2\n#endif\n\n/* USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ */\n#ifndef PLL_Q\n#define PLL_Q      7\n#endif\n\n\nuint32_t SystemCoreClock = 168000000;\n\n__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};\n\nstatic void SetSysClock(void);\n#ifdef DATA_IN_ExtSRAM\n  static void SystemInit_ExtMemCtl(void); \n#endif /* DATA_IN_ExtSRAM */\n\nvoid SystemInit(void)\n{\n  /* FPU settings ------------------------------------------------------------*/\n  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)\n    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */\n  #endif\n  /* Reset the RCC clock configuration to the default reset state ------------*/\n  /* Set HSION bit */\n  RCC->CR |= (uint32_t)0x00000001;\n\n  /* Reset CFGR register */\n  RCC->CFGR = 0x00000000;\n\n  /* Reset HSEON, CSSON and PLLON bits */\n  RCC->CR &= (uint32_t)0xFEF6FFFF;\n\n  /* Reset PLLCFGR register */\n  RCC->PLLCFGR = 0x24003010;\n\n  /* Reset HSEBYP bit */\n  RCC->CR &= (uint32_t)0xFFFBFFFF;\n\n  /* Disable all interrupts */\n  RCC->CIR = 0x00000000;\n\n#ifdef DATA_IN_ExtSRAM\n  SystemInit_ExtMemCtl(); \n#endif /* DATA_IN_ExtSRAM */\n         \n  /* Configure the System clock source, PLL Multiplier and Divider factors, \n     AHB/APBx prescalers and Flash settings ----------------------------------*/\n  SetSysClock();\n\n  /* Configure the Vector Table location add offset address ------------------*/\n#ifdef VECT_TAB_SRAM\n  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */\n#else\n  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */\n#endif\n}\n\n/* Calculate SystemCoreClock based on the configuration register values */\nvoid SystemCoreClockUpdate(void)\n{\n  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;\n  \n  /* Get SYSCLK source -------------------------------------------------------*/\n  tmp = RCC->CFGR & RCC_CFGR_SWS;\n\n  switch (tmp)\n  {\n    case 0x00:  /* HSI used as system clock source */\n      SystemCoreClock = HSI_VALUE;\n      break;\n    case 0x04:  /* HSE used as system clock source */\n      SystemCoreClock = HSE_VALUE;\n      break;\n    case 0x08:  /* PLL used as system clock source */\n\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N\n         SYSCLK = PLL_VCO / PLL_P\n         */    \n      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\n      \n      if (pllsource != 0)\n      {\n        /* HSE used as PLL clock source */\n        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);\n      }\n      else\n      {\n        /* HSI used as PLL clock source */\n        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      \n      }\n\n      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;\n      SystemCoreClock = pllvco/pllp;\n      break;\n    default:\n      SystemCoreClock = HSI_VALUE;\n      break;\n  }\n  /* Compute HCLK frequency --------------------------------------------------*/\n  /* Get HCLK prescaler */\n  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];\n  /* HCLK frequency */\n  SystemCoreClock >>= tmp;\n}\n\n/* Set the system clock */\nstatic void SetSysClock(void)\n{\n/******************************************************************************/\n/*            PLL (clocked by HSE) used as System clock source                */\n/******************************************************************************/\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* Enable HSE */\n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;\n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }\n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */\n    RCC->APB1ENR |= RCC_APB1ENR_PWREN;\n    PWR->CR |= PWR_CR_VOS;\n\n    /* HCLK = SYSCLK / 1*/\n    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK / 2*/\n    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;\n    \n    /* PCLK1 = HCLK / 4*/\n    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;\n\n    /* Configure the main PLL */\n    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |\n                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);\n\n    /* Enable the main PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till the main PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n   \n    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */\n    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;\n\n    /* Select the main PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= RCC_CFGR_SW_PLL;\n\n    /* Wait till the main PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock\n         configuration. User can add here some code to deal with this error */\n  }\n\n}\n\n/**\n  * @brief  Setup the external memory controller. Called in startup_stm32f4xx.s \n  *          before jump to __main\n  * @param  None\n  * @retval None\n  */ \n#ifdef DATA_IN_ExtSRAM\n/**\n  * @brief  Setup the external memory controller.\n  *         Called in startup_stm32f4xx.s before jump to main.\n  *         This function configures the external SRAM mounted on STM324xG_EVAL/STM324x7I_EVAL board\n  *         This SRAM will be used as program data memory (including heap and stack).\n  * @param  None\n  * @retval None\n  */\nvoid SystemInit_ExtMemCtl(void)\n{\n/*-- GPIOs Configuration -----------------------------------------------------*/\n/*\n +-------------------+--------------------+------------------+------------------+\n +                       SRAM pins assignment                                   +\n +-------------------+--------------------+------------------+------------------+\n | PD0  <-> FSMC_D2  | PE0  <-> FSMC_NBL0 | PF0 <-> FSMC_A0  | PG0 <-> FSMC_A10 |\n | PD1  <-> FSMC_D3  | PE1  <-> FSMC_NBL1 | PF1 <-> FSMC_A1  | PG1 <-> FSMC_A11 |\n | PD4  <-> FSMC_NOE | PE2  <-> FSMC_A23  | PF2 <-> FSMC_A2  | PG2 <-> FSMC_A12 |\n | PD5  <-> FSMC_NWE | PE3  <-> FSMC_A19  | PF3 <-> FSMC_A3  | PG3 <-> FSMC_A13 |\n | PD8  <-> FSMC_D13 | PE4  <-> FSMC_A20  | PF4 <-> FSMC_A4  | PG4 <-> FSMC_A14 |\n | PD9  <-> FSMC_D14 | PE5  <-> FSMC_A21  | PF5 <-> FSMC_A5  | PG5 <-> FSMC_A15 |\n | PD10 <-> FSMC_D15 | PE6  <-> FSMC_A22  | PF12 <-> FSMC_A6 | PG9 <-> FSMC_NE2 |\n | PD11 <-> FSMC_A16 | PE7  <-> FSMC_D4   | PF13 <-> FSMC_A7 |------------------+\n | PD12 <-> FSMC_A17 | PE8  <-> FSMC_D5   | PF14 <-> FSMC_A8 |\n | PD13 <-> FSMC_A18 | PE9  <-> FSMC_D6   | PF15 <-> FSMC_A9 |\n | PD14 <-> FSMC_D0  | PE10 <-> FSMC_D7   |------------------+\n | PD15 <-> FSMC_D1  | PE11 <-> FSMC_D8   |\n +-------------------| PE12 <-> FSMC_D9   |\n                     | PE13 <-> FSMC_D10  |\n                     | PE14 <-> FSMC_D11  |\n                     | PE15 <-> FSMC_D12  |\n                     +--------------------+\n*/\n   /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */\n  RCC->AHB1ENR   |= 0x00000078;\n  \n  /* Connect PDx pins to FSMC Alternate function */\n  GPIOD->AFR[0]  = 0x00cc00cc;\n  GPIOD->AFR[1]  = 0xcccccccc;\n  /* Configure PDx pins in Alternate function mode */  \n  GPIOD->MODER   = 0xaaaa0a0a;\n  /* Configure PDx pins speed to 100 MHz */  \n  GPIOD->OSPEEDR = 0xffff0f0f;\n  /* Configure PDx pins Output type to push-pull */  \n  GPIOD->OTYPER  = 0x00000000;\n  /* No pull-up, pull-down for PDx pins */ \n  GPIOD->PUPDR   = 0x00000000;\n\n  /* Connect PEx pins to FSMC Alternate function */\n  GPIOE->AFR[0]  = 0xcccccccc;\n  GPIOE->AFR[1]  = 0xcccccccc;\n  /* Configure PEx pins in Alternate function mode */ \n  GPIOE->MODER   = 0xaaaaaaaa;\n  /* Configure PEx pins speed to 100 MHz */ \n  GPIOE->OSPEEDR = 0xffffffff;\n  /* Configure PEx pins Output type to push-pull */  \n  GPIOE->OTYPER  = 0x00000000;\n  /* No pull-up, pull-down for PEx pins */ \n  GPIOE->PUPDR   = 0x00000000;\n\n  /* Connect PFx pins to FSMC Alternate function */\n  GPIOF->AFR[0]  = 0x00cccccc;\n  GPIOF->AFR[1]  = 0xcccc0000;\n  /* Configure PFx pins in Alternate function mode */   \n  GPIOF->MODER   = 0xaa000aaa;\n  /* Configure PFx pins speed to 100 MHz */ \n  GPIOF->OSPEEDR = 0xff000fff;\n  /* Configure PFx pins Output type to push-pull */  \n  GPIOF->OTYPER  = 0x00000000;\n  /* No pull-up, pull-down for PFx pins */ \n  GPIOF->PUPDR   = 0x00000000;\n\n  /* Connect PGx pins to FSMC Alternate function */\n  GPIOG->AFR[0]  = 0x00cccccc;\n  GPIOG->AFR[1]  = 0x000000c0;\n  /* Configure PGx pins in Alternate function mode */ \n  GPIOG->MODER   = 0x00080aaa;\n  /* Configure PGx pins speed to 100 MHz */ \n  GPIOG->OSPEEDR = 0x000c0fff;\n  /* Configure PGx pins Output type to push-pull */  \n  GPIOG->OTYPER  = 0x00000000;\n  /* No pull-up, pull-down for PGx pins */ \n  GPIOG->PUPDR   = 0x00000000;\n  \n/*-- FSMC Configuration ------------------------------------------------------*/\n  /* Enable the FSMC interface clock */\n  RCC->AHB3ENR         |= 0x00000001;\n\n  /* Configure and enable Bank1_SRAM2 */\n  FSMC_Bank1->BTCR[2]  = 0x00001011;\n  FSMC_Bank1->BTCR[3]  = 0x00000201;\n  FSMC_Bank1E->BWTR[2] = 0x0fffffff;\n/*\n  Bank1_SRAM2 is configured as follow:\n\n  p.FSMC_AddressSetupTime = 1;\n  p.FSMC_AddressHoldTime = 0;\n  p.FSMC_DataSetupTime = 2;\n  p.FSMC_BusTurnAroundDuration = 0;\n  p.FSMC_CLKDivision = 0;\n  p.FSMC_DataLatency = 0;\n  p.FSMC_AccessMode = FSMC_AccessMode_A;\n\n  FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;\n  FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;\n  FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;\n  FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;\n  FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;\n  FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  \n  FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;\n  FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;\n  FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;\n  FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;\n  FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;\n  FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;\n  FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;\n  FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;\n  FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;\n*/\n}\n#endif /* DATA_IN_ExtSRAM */\n\n\n/* EOF */"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};